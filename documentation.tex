\documentclass[a4paper,12pt]{report}
\usepackage{algorithme}
\usepackage[francais]{babel}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{algorithme}
\usepackage{listings}
\usepackage{color}
\usepackage{supertabular}
\usepackage{fullpage}



%%Configuration de listings -----------------------------------
\definecolor{colKeys}{rgb}{0,0,1}
\definecolor{colIdentifier}{rgb}{0,0,0}
\definecolor{colComments}{rgb}{0,0.5,1}
\definecolor{colString}{rgb}{0.6,0.6,0.1}

\lstset{%configuration de listings
float=hbp,%
basicstyle=\ttfamily\small, %
identifierstyle=\color{colIdentifier}, %
keywordstyle=\color{colKeys}, %
stringstyle=\color{colString}, %
commentstyle=\color{colComments}, %
columns=flexible, %
tabsize=2, %
frame=trBL, %
frameround=tttt, %
extendedchars=true, %
showspaces=false, %
showstringspaces=false, %
numbers=left, %
numberstyle=\tiny, %1
breaklines=true, %
breakautoindent=true, %
captionpos=b,%
xrightmargin=0cm, %
xleftmargin=-0cm, %
language=tex, %
frameround=fttt;%
}
%%Fin de la configuration de listings -----------------------------------



\title{Documentation du package  algorithme.sty \\version 2.3.6}
\author{RANDRIANARIVELO Tiana \\ MSSALAK Meryem \\ ZERJAL Dimitri \\ AMIRAULT Martin}
\begin{document}

\maketitle
\tableofcontents{}


\chapter{Pr�sentation du package}

\section{G�n�ralit�s}

Ce package est destin� � afficher des algorithmes dans les documents \LaTeX.
La pr�sentation et la syntaxe ont �t� cr�� de mani�re � ce que les algorithmes soient compr�hensibles par tous. 
Le surlignage en gras des termes important ainsi que l'indentation est faite automatiquement. Par ailleurs, tout les �lements algorithmiques sont en fran�ais.
Le langage utilis� est d�tach� de toute syntaxe sp�cifique aux langages de programmation existants. Ceci permet de porter ais�ment l'algorithme dans n'importe lequel de ces langages.



\section{Historique}

La version stable du package \textbf{algorithme} est actuellement la version 2.3.6.
Voici l'historique des changements du package depuis sa sortie : 
\begin{itemize}
%% Envoyer toutes remarques a Nicolas.Delestre@insa-rouen.fr

  \item Modifications de puis la version 2.6\\
    \textbullet   Am�lioration de la notation des pointeurs

  \item Modifications depuis la version 2.4\\
    \textbullet   Ajoute des commandes \textbackslash typeProcedure, \textbackslash typeFonction, \textbackslash typeProcedureAvecPreconditions, \textbackslash typeFonctionAvecPreconditions

  \item Modifications depuis la version 2.3.8\\
    \textbullet   Ajout de la commande \textbackslash tadOperationAvecPreconditions\\
    \textbullet   Ajout des environnement tadPreconditions et des commandes \textbackslash motclefTADPreconditions  et \textbackslash tadPrecondition\\
    \textbullet   Ajout de la commande \textbackslash champ


  \item Modifications depuis la version 2.3.7\\
    \textbullet   Ajout des types de base naturelNonNul, reelPositif, reelPositifNonNul (resp Negatif)\\
    \textbullet   Elimination d'accents dans les mots cles lies � l'algorithmique\\
    \textbullet   ajout de la commande \textbackslash commentaire
    
  \item Modification depuis la version 2.3.6 :\\
    \textbullet   Ajout des commandes \textbackslash fonctionAvecPreconditions \textbackslash signatureFonctionAvecPreconditions, \textbackslash procedureAvecPreconditions et \textbackslash signatureProcedureAvecPreconditions\\
    \textbullet   remplacement de structure et champEnregistrement par enregistrement et champEnregistrement\\

  \item  Modification depuis la version 2.3.5 :\\
   \textbullet   suppression de la commande \textbackslash programme
  
  \item Modification depuis la version 2.3.4 :\\
   \textbullet   Dans les commandes fonction et procedure, modification du test pour savoir si les variables locales sont presentes ou pas\\
   \textbullet   Suppression de l'erreur de compilation du a la redefinition de l'environnement structure\\

  \item  Modification depuis la version 2.3.2 :\\
   \textbullet structure est maintenant un environnement qui s'integre dans l'environnement algorithme\\
   \textbullet \textbackslash champEnregistrement a pris une majuscule\\
   \textbullet Apparition de \texttt{\textbackslash tadSemantiquesAxiomatiques}\\
   \textbullet   Apparition de l'environnement \texttt{\textbackslash tadAxiomes} et commande \texttt{\textbackslash tadAxiome}\\
   \textbullet   Apparition de \texttt{\textbackslash typePointeur}, \texttt{\textbackslash pointeur},\texttt{\textbackslash \pointeurNULL}, \texttt{\textbackslash champPointeur}, \texttt{\textbackslash allouer}, \texttt{\textbackslash desallouer}\\
   \textbullet   Elimination de l'erreur de compilation li� � la d�finition de la commande \texttt{\textbackslash structure}
\end{itemize}

\section{Installation}

Il y trois mani�res d'installer le Package \textbf{algorithme.sty} : 
\begin{enumerate}
  \item Il suffit de mettre le package dans le m�me dossier que le document lui-m�me.
L' inconv�nient de cette m�thode est qu'il faut toujours recopier le package \textbf{algorithme.sty} � chaque fois que l'on fait un nouveau document dans un autre dossier.

 \item La deuxi�me m�thode consiste � chercher le dossier \textbf{texmf} dans le system, puis de copier le package \textbf{algorithme.sty} dans le dossier \textbf{tex} ( Normalement, ce dossier devrait se trouver dans \texttt{/usr/share/texmf/tex/} ) .Mais cette m�thode reste dangereuse par le fait qu'il faut �tre root pour le faire. 

 \item La derni�re m�thode, qui est la m�thode plus propre,  permet d'installer une fois pour toute le package sur la machine peut importe l'emplacement des documents sources \LaTeX.Il suffit de param�trer le variable d'environment \textbf{HOMETEXMF}, en lui donnant comme valeur le r�peroire o� se trouve ses propres packages \LaTeX .

\end{enumerate}



\chapter{Utilisation du package}
Une fois install� (voir le paragraphe Installation), l'utilisation est semblable aux autres packages \LaTeX :


En t�te du fichier \LaTeX, inclure la ligne suivante
\begin{lstlisting}
\usepackage{algorithme}
\end{lstlisting}

\section{L 'environnement Algorithme}

Entourer chaque algorithme par les balises suivantes:
\begin{lstlisting}
  \begin{algorithme}
...
  \end{algorithme}
\end{lstlisting}


\subsection{En-t�te}

Les differents en-t�tes disponibles dans le package sont les suivants:


\begin{lstlisting}
\algorithme{1}{2}{3}{4}{5}{6}{7}{8}
(1):Taille de la police
(2):Nom de l'algorithme
(3):R�le de l'algorithme 
(4):Param�tres en entr�e
(5):Param�tres en sortie
(6):Param�tres en entr�e/sortie
(7):D�claration variables locales
(8):Corps de l'algorithme
\end{lstlisting}

Exemple:

\begin{lstlisting}
\algo{\normalsize}
{exemple d'algo}
{pr�senter l'utilisation d'algo}
{n : \entier}
{m: \entier}
{t: \entier}
{i: \reel}
{\instruction{corps du programme}}
\end{lstlisting}

\begin{algorithme}
  \algo{\normalsize}
  {exemple d'algo}
  {pr�senter l'utilisation d'algo}
  {n : \entier}
  {m: \entier}
  {t: \entier}
  {i: \reel}
  {\instruction{corps du programme}}

\end{algorithme}


\subsection{Les types de base}

\subsubsection{Types simples}

Les commandes pour utiliser les types simples sont les suivantes:
\begin{lstlisting}
  Entier: \entier
  Entier naturel : \naturel
  R�el: \reel
  Bool�en: \booleen
  Caract�re: \caractere
  Chaine de caract�res: \chaine
\end{lstlisting}

Exemple:

\begin{lstlisting}
  \algo
  {\normalsize}
  {Exemple de programme}
  {}
  {n: \naturel; e : \entier; r \reel; b: \booleen; c: \caractere; ch: \chaine}
  {}
  {}
  {}
  {\instruction{corps du programme}}

\end{lstlisting}

\begin{algorithme}
  \algo
  {\normalsize}
  {Exemple de programme}
  {}
  {n: \naturel; e : \entier; r \reel; b: \booleen; c: \caractere; ch: \chaine}
  {}
  {}
  {} 
  {\instruction{corps du programme}}

\end{algorithme}

\subsubsection{Types complexes}

Les commandes pour utiliser les types complexes sont les suivantes:
\begin{lstlisting}
  constante: \constante{1}{2}
(1): Nom de la constante
(2): Valeur de la constante

tableau unidimensionnel: \tableauUneDimension{1}{2}{3}
(1): Intervalle
(2): {de} ou {d'}
(3): Type

tableau bidimensionnel: \tableauDeuxDimensions {1}{2}{3}{4}
(1): Intervalle 1ere dimension
(2): Intervalle 2eme dimension
(3): {de} ou {d'}
(4): Type

\end{lstlisting}

 Exemples:
\begin{lstlisting}
  \algo
  {\normalsize}
  {Exemple de programme}
  {}
  
  {
  const: \constante{const}{2},
  tab1d: \tableauUneDimension{10}{d'}{\entier},
  tab2d: \tableauDeuxDimensions{10}{20}{de}{\reel}
  }
  {}
  {}
  {}
  {\instruction{}}

\end{lstlisting}

\begin{algorithme}
  \algo
  {\normalsize}
  {Exemple de programme}
  {}
  {
  const: \constante{const}{2},
  tab1d: \tableauUneDimension{10}{d'}{\entier},
  tab2d: \tableauDeuxDimensions{10}{20}{de}{\reel}
  }
  {}
  {}
  {}
  {\instruction{}}
\end{algorithme}



\subsection{Les instructions �l�mentaires}
Les instructions �l�mentaires sont l'affectation, la lecture et l'�criture de donn�es, les commandes n�cessaires pour les utiliser sont les suivantes:
\begin{lstlisting}
  affectation: \affecter{1}{2}
(1): Nom de la variable
(2): Valeur

 �criture: \ecrire{1}
(1): Ce qui doit �tre afficher

 lecture: \lire{1}
(1): Variable
\end{lstlisting}

Exemple:

\begin{lstlisting}
  \procedure
  {ajouterNombre}
  {a: \entier}
  {i: \entier}
  {
    \affecter{i}{0}
    \ecrire{Veuillez donner une valeur � ajouter � a}
    \lire{i}
    \affecter{a}{a + i}
  }
\end{lstlisting}


\begin{algorithme}
  \procedure
  {ajouterNombre}
  {a: \entier}
  {i: \entier}
  {
    \affecter{i}{0}
    \ecrire{Veuillez donner une valeur � ajouter � a}
    \lire{i}
    \affecter{a}{a + i}
  }
\end{algorithme}

\subsection {Les tests}

\begin{itemize}
   \item Sup�rieur ou �gal ( $\geq$ )
       \begin{lstlisting}
          $\geq$
       \end{lstlisting}

   \item Inf�rieur ou �gal ( $\leq$ )

        \begin{lstlisting}
          $\leq$
        \end{lstlisting}

   \item Diff�rent de ( $\neq$ )

        \begin{lstlisting}
          $\neq$
        \end{lstlisting}

   \item Egal � ( = )
        \begin{lstlisting}
          =
        \end{lstlisting}
   \item Sup�rieur ( $>$ )
        \begin{lstlisting}
          $>$
        \end{lstlisting}
   \item Inf�rieur ( $<$ )

        \begin{lstlisting}
          $<$
        \end{lstlisting}
\end{itemize}

 \subsection {Les conditionnelles}
   \begin{lstlisting}
       \sialors{1}{2}
(1): Test de la conditionnelle
(2): Code � exectuter si le test est v�rifi�
        \sialorssinon{1}{2}{3}
(1): Test de la conditionnelle
(2): Code � executer si le test est v�rifi�
(3): Code � executer si le test n'est pas v�rifi�
   \end{lstlisting}

 Exemple:

 \begin{lstlisting}
    \begin{algorithme}
    \algo 
        {\small}
        {Test du signe d'un entier}
        {}
        {n : \entier}
        {}
        {}
        {}
        {
          \lire {n}
          \sialorssinon{n $\geq$ 0}
             {
               \ecrire{Vous avez entr� un entier positif ou nul}
             }
             {
               \ecrire{Vous avez entr� un entier n�gatif}
             }
       }
   \end{algorithme}
\end{lstlisting}

 \begin{algorithme}
    \algo
        {\small}
        {Test du signe d'un entier}
        {}
        {n : \entier}
        {}
        {}
        {}
        {
          \lire {n}
          \sialorssinon{n $\geq$ 0}
             {
               \ecrire{Vous avez entr� un entier positif ou nul}
             }
             {
               \ecrire{Vous avez entr� un entier n�gatif}
             }
       }
 \end{algorithme}


 \subsection{Les boucles}
 \subsubsection{det�rministes}

 \begin{lstlisting}
 \pour{1}{2}{3}{4}{5}
(1):Nom de la variable
(2):Borne inf�rieure
(3):Borne Sup�rieure
(4):Pas (si non renseign�, 1)
(5):Corps de la boucle
 \end{lstlisting}


 \begin{lstlisting}
 \begin{algorithme}
     \algo 
     {\small}
     {Afficher les nombres de 1 � 100}
     {}
     {n : \naturel}
     {}
     {}
     {}
     {
        \pour{n}{1}{100}{}
           {
             \ecrire{n}
           }
     }
 \end{algorithme}

 \end{lstlisting}

 \begin{algorithme}
     \algo 
     {\small}
     {Afficher les nombres de 1 � 100}
     {}
     {n : \naturel}
     {}
     {}
     {}
     {
        \pour{n}{1}{100}{}
           {
             \ecrire{n}
           }
     }
 \end{algorithme}

 \subsubsection{indet�rministes}
   \begin{lstlisting}
     \tantque{1}{2}
(1):Test de la boucle
(2):Corps de la boucle
   \end{lstlisting}

Exemple:
\begin{lstlisting}
  \begin{algorithme}
    \algo
    {\small}
    {Afficher les nombres de 1 � ?}
    {}
    {n : \naturel}
    {bornesup : \naturel}
    {}
    {}
    {
      \ecrire{Afficher les nombres de 1 � ?}
      \lire {bornesup}
      \tantque{n$<$bornesup+1}
         {
           \ecrire{n}
           \affecter {n}{n+1}
         }
    }
  \end{algorithme}
\end{lstlisting}

  \begin{algorithme}
    \algo
    {\small}
    {Afficher les nombres de 1 � }
    {}
    {n : \naturel}
    {bornesup : \naturel}
    {}
    {}
    {
      \affecter {n}{1}
      \ecrire{Afficher les nombres de 1 � ?}
      \lire {bornesup}
      \tantque{n $<$ bornesup+1}
         {
           \ecrire{n}
           \affecter {n}{n+1}
         }
    }
  \end{algorithme}



La commande \texttt{\textbackslash repeter} permet d'effectuer une boucle en ex�cutant au moins une fois le corps de boucle.

  \begin{lstlisting}
    \repeter{1}{2}
(1):Corps de la boucle
(2):Test de la boucle
  \end{lstlisting}
Exemple:
  \begin{lstlisting}
 \begin{algorithme}
   \algo 
   {\small}
   {Entrer un nombre entre 1 et 5}
   {}
   {}
   {}
   {reponse : \naturel}
   {}
   {
     \affecter{reponse}{0}
     \repeter {
       \ecrire {Entrez un nombre entre 1 et 5}
       \lire {reponse}
        }
       {(reponse $<$ 1)}
   }
 \end{algorithme}
\end{lstlisting}

 \begin{algorithme}
   \algo 
   {\small}
   {Entrer un nombre entre 1 et 5}
   {}
   {}
   {}
   {reponse : \naturel}
   {}
   { \affecter{reponse}{0}
     \repeter {
       \ecrire {Entrez un nombre entre 1 et 5}
       \lire {reponse}
        }
       {(reponse $<$ 1)}
   }
 \end{algorithme}

\subsection{Les fonctions et les proc�dures}

\subsubsection{Les fonctions}
\paragraph{Sans pr�condition(s)}
Pour ins�rer une fonction, il faut utiliser la commande \texttt{\textbackslash fonction}  qui prend en param�tre cinq arguments :
\begin{lstlisting}
\fonction {1}{2}{3}{4}{5}
 (1) Le nom de la fonction 
 (2) Les param�tres 
 (3) Le type de retour
 (4) Les variables locales
 (5) Les instructions
\end{lstlisting}

Dans la liste des instructions, il doit y avoir au moins une fois
l'appel � la commande \texttt{\textbackslash retourner} qui admet un
argument en param�tre.

Exemple d'utilisation de la commande \texttt{\textbackslash fonction}

\begin{lstlisting}
\begin{algorithme}
  \small
  \fonction
  {abs}
  {unEntier : \entier}
  {\entier}
  {}
  {\sialorssinon{unEntier $\geq$ 0}
    {\retourner{unEntier}}
    {\retourner{-unEntier}}
  }    
\end{algorithme}
\end{lstlisting}


\begin{algorithme}
    \small
    \fonction
    {abs}
    {unEntier : \entier}
    {\entier}
    {}
    {\sialorssinon{unEntier $\geq$ 0}
      {\retourner{unEntier}}
      {\retourner{-unEntier}}
    }    
  \end{algorithme}

\paragraph{Avec Pr�conditions}
Pour ins�rer une fonction avec pr�condition(s), il faut utiliser la commande \texttt{\textbackslash fonctionAvecPreconditions}  qui prend en param�tre six arguments :
\begin{lstlisting}
\fonction {1}{2}{3}{4}{5}{6}
 (1) Le nom de la fonction 
 (2) Les param�tres 
 (3) Le type de retour
 (4) Les pr�conditions
 (5) Les variables locales
 (6) Les instructions
\end{lstlisting}

Dans la liste des instructions, il doit y avoir au moins une fois
l'appel � la commande \texttt{\textbackslash retourner} qui admet un
argument en param�tre.

Exemple d'utilisation de la commande \texttt{\textbackslash fonctionAvecPreconditions}

\begin{lstlisting}
\begin{algorithme}
  \small
  \fonctionAvecPreconditions
  {abs}
  {unEntier : \entier}
  {\entier}
  {}
  {}
  {\sialorssinon{unEntier $\geq$ 0}
    {\retourner{unEntier}}
    {\retourner{-unEntier}}
  }    
\end{algorithme}
\end{lstlisting}


\begin{algorithme}
    \small
    \fonctionAvecPreconditions
    {abs}
    {unEntier : \entier}
    {\entier}
    {estR�el(UnEntier)}
    {}
    {\sialorssinon{unEntier $\geq$ 0}
      {\retourner{unEntier}}
      {\retourner{-unEntier}}
    }    
  \end{algorithme}


\subsubsection{Signature de fonction}
\paragraph{Sans Pr�condition(s)}
Pour ins�rer une signature de fonction, il faut utiliser la commande
\texttt{\textbackslash signaturefonction} qui prend en param�tre trois
arguments identiques aux trois premiers param�tres de la commande \texttt{\textbackslash fonction}
\begin{lstlisting}
\signaturefonction {1}{2}{3}
 (1) Le nom de la fonction 
 (2) Les param�tres 
 (3) Le type de retour
 \end{lstlisting}

\paragraph{Avec Pr�condtitions}
\texttt{\textbackslash signatureFonctionAvecPreconditions} qui prend en param�tre quatre
arguments identiques aux quatre premiers param�tres de la commande \\
\texttt{\textbackslash fonctionAvecPreconditions}
\begin{lstlisting}
\signatureFonctionAvecPreconditions {1}{2}{3}{4}
 (1) Le nom de la fonction 
 (2) Les param�tres 
 (3) Le type de retour
 (4) Les pr�conditions
 \end{lstlisting}
 
 
\subsubsection{Les proc�dures}
\paragraph{Sans Précondition}
Pour ins�rer une proc�dure, il faut utiliser la commande\texttt{\textbackslash procedure} qui prend en param�tre quatre arguments:
\begin{lstlisting}
\procedure {1}{2}{3}{4} 
 (1) nom de la proc�dure
 (2) Les param�tres
 (3) Les variables locales
 (4) Les instructions
\end{lstlisting}

Pour indiquer le passage de param�tre, on peut utiliser les commandes
\texttt{\textbackslash paramEntree}, \texttt{\textbackslash
  paramSortie} et \texttt{\textbackslash paramEntreeSortie}. Ces trois
commandes prennent un seul argument.

Exemple d'utilisation de la commande \texttt{\textbackslash procedure}
\begin{lstlisting}
\begin{algorithme}
  \small
  \procedure
  {echanger}
  {\paramEntreeSortie{val1,val2 : \entier}}
  {temp : \entier}
  {\affecter{temp}{val1}
    \affecter {val1}{val2}
    \affecter {val2}{temp}
  }
\end{algorithme}
\end{lstlisting}
\begin{algorithme}
    \small
    \procedure
    {echanger}
    {\paramEntreeSortie{val1,val2 : \entier}}
    {temp : \entier}
    {\affecter{temp}{val1}
      \affecter {val1}{val2}
      \affecter {val2}{temp}
    }
  \end{algorithme}

\paragraph{Avec Précondition}
Pour ins�rer une proc�dure avec précondition, il faut utiliser la commande\texttt{\textbackslash procedurfonctionAvecPreconditionse} qui prend en param�tre cinq arguments:
\begin{lstlisting}
\fonctionAvecPreconditions {1}{2}{3}{4}{5}
 (1) nom de la proc�dure
 (2) Les param�tres
 (3) Les préconditions
 (4) Les variables locales
 (5) Les instructions
\end{lstlisting}

Pour indiquer le passage de param�tre, on peut utiliser les commandes
\texttt{\textbackslash paramEntree}, \texttt{\textbackslash
  paramSortie} et \texttt{\textbacksla

\subsubsection{Signature de proc�dure}
\paragraph{Sans Préconditions}
Tout comme pour les fonctions, on a la possibilit� d'�crire une
signature de proc�dure � l'aide de la commande \texttt{\textbackslash
  signatureprocedure} qui prend en param�tre deux arguments identiques
aux deux premiers arguments de la commande \texttt{\textbackslash  procedure}

\begin{lstlisting}
\procedure {1}{2}
 (1) nom de la proc�dure
 (2) Les param�tres
\end{lstlisting}
  
\begin{lstlisting}
\algo
  {\small}
  {\textit{exemple}}
  {}
  {\variables{entier1,entier2,entier3,min,max : \entier}
    \signaturefonction{minimum2}{a,b : \entier}{\entier}
    \signaturefonction{minimum3}{a,b,c : \entier}{\entier}
    \procedure{calculerMinMax3}{\paramEntree{a,b,c : \entier};\paramSortie{min3,max3 : \entier}}
    {}
    {\affecter{min3}{minimum3(a,b,c)}
      \affecter{max3}{maximum3(a,b,c)}
    }
  }
  {}
  {}
  {}
  {\ecrire{"Entrez trois entiers :"}
    \lire{entier1}
    \lire{entier2}
    \lire{entier3}
    \instruction{calculerMinMax3(entier1,entier2,entier3,min,max)}
    \ecrire{"la valeur la plus petite est ",min," et la plus grande est ",max}
  }
\end{lstlisting}

Ce qui donne : 
\begin{algorithme}
  \algo
  {\small}
  {\textit{exemple}}
  {}
  {\variables{entier1,entier2,entier3,min,max : \entier}
    \signaturefonction{minimum2}{a,b : \entier}{\entier}
    \signaturefonction{minimum3}{a,b,c : \entier}{\entier}
    \procedure{calculerMinMax3}{\paramEntree{a,b,c : \entier};\paramSortie{min3,max3 : \entier}}
    {}
    {\affecter{min3}{minimum3(a,b,c)}
      \affecter{max3}{maximum3(a,b,c)}
    }
  }
  {}
  {}
  {}
  {\ecrire{"Entrez trois entiers :"}
    \lire{entier1}
    \lire{entier2}
    \lire{entier3}
    \instruction{calculerMinMax3(entier1,entier2,entier3,min,max)}
    \ecrire{"la valeur la plus petite est ",min," et la plus grande est ",max}
  }
\end{algorithme}

\paragraph{Avec Préconditions}
Tout comme pour les fonctions, on a la possibilit� d'�crire une
signature de proc�dure avec préconditions � l'aide de la commande \texttt{\textbackslash
  signatureProcedureAvecPreconditions} qui prend en param�tre trois arguments identiques
aux trois premiers arguments de la commande \texttt{\textbackslash  procedure}

\begin{lstlisting}
\procedure {1}{2}
 (1) nom de la proc�dure
 (2) Les param�tres
 (3) Les préconditions
\end{lstlisting}

 \subsection{Les pointeurs}
\begin{itemize}
\item Pour d�finir le type de l'�lement point� on utilise la commande \texttt{\textbackslash typePointeur} qui prend un seul argument en param�tre.
\begin{lstlisting}
\typePointeur {1}
 (1) le type de l'element point�
\end{lstlisting}
\item Pour d�clarer un pointeur on utilise la commande \texttt{\textbackslash pointeur} qui prend un seul argument en param�tre.
\begin{lstlisting}
\pointeur {1}
 (1) l'adresse de l'�lement point�
\end{lstlisting}
\item Par d�faut lorsqu'on d�clare un pointeur, on ne sait pas sur quoi il pointe, on peut donc lui affecter � l'initialisation la valeur NULL  en utilisant la commande \texttt{\textbackslash pointeurNULL}  qui prend aucun argument en param�tre.

\item Pour d�finir le type du pointeur on utilise la commande \texttt{\textbackslash champPointeur} qui prend deux arguments en param�tre:
\begin{lstlisting}
\champPointeur {1}{2}
 (1) le pointeur 
 (1) l'�lement point�
\end{lstlisting}
\item Pour allouer/d�sallouer un espace m�moire on utilise respectivement les commandes suivantes \texttt{\textbackslash allouer} et \texttt{\textbackslash desallouer} qui prennent en param�tre un seul argument
\begin{lstlisting}
\allouer {1}
 (1) l'adresse allou�e

\desallouer {1}
 (1) l'adresse d�sallou�e
\end{lstlisting}
\end{itemize}


Exemple d'utilisation des pointeurs


\begin{lstlisting}
\begin{algorithme}
\type{listeChainee}{\typePointeur{noeud}}
\end{algorithme}

\begin{algorithme}
\begin{enregistrement}{noeud}
  \champEnregistrement{lElement}{Element}
  \champEnregistrement{listeSuivante}{listeCha�n�e}
\end{enregistrement}
\end{algorithme}

\begin{algorithme}

\procedure{ajouter}
{\paramEntreeSortie{l:ListeCha�n�e} \paramEntree{e: Element}}
{temp: ListeCha�n�e}
{
 \affecter{temp}{l}
\affecter{l}{\allouer{noeud}}
\affecter{\champPointeur{l}{Element}}{e}
\instruction{fixerListeSuivante(l,temp)}
}
\end{algorithme}
\end{lstlisting}

Ce qui donne :
\begin{algorithme}
\type{listeChainee}{\typePointeur{noeud}}
\end{algorithme}

\begin{algorithme}
\begin{enregistrement}{noeud}
  \champEnregistrement{lElement}{Element}
  \champEnregistrement{listeSuivante}{listeCha�n�e}
\end{enregistrement}
\end{algorithme}

\begin{algorithme}

\procedure{ajouter}
{\paramEntreeSortie{l:ListeCha�n�e} \paramEntree{e: Element}}
{temp: ListeCha�n�e}
{
 \affecter{temp}{l}
\affecter{l}{\allouer{noeud}}
\affecter{\champPointeur{l}{Element}}{e}
\instruction{fixerListeSuivante(l,temp)}

}

\end{algorithme}

\section{L'environment Enregistrement}

Les structures sont d�clar�es au sein m�me de l'environnement algorithme (entre les balises \textbackslash begin\{algorithme\} et \textbackslash end\{algorithme\}).

La syntaxe est la suivante:
\begin{lstlisting}
\begin{enregistrement}{1}
        \champEnregistrement{2}{3}
  ...
\end{enregistrement}

(1):Nom de la structure
(2):Nom du premier champ de la structure
(3):type du premier champ de la structure
\end{lstlisting}


\begin{lstlisting}

\begin{algorithme}
\begin{enregistrement}{date}
        \champEnregistrement{leJour}{\entier}
        \champEnregistrement{leMois}{\entier}
       \champEnregistrement{lAnnee}{\entier}
\end{enregistrement}
\end{algorithme}
\end{lstlisting}
\begin{algorithme}
\begin{enregistrement}{date}
        \champEnregistrement{leJour}{\entier}
        \champEnregistrement{leMois}{\entier}
       \champEnregistrement{lAnnee}{\entier}
\end{enregistrement}
\end{algorithme}



\section{L'environment TAD}


On a aussi la possibilit� de d�finir des types abstraits de donn�es
(que l'on retrouve dans la litt�rature sous les termes ``types de donn�es
abstraits'' ou ``abstract datatype'').

\begin{lstlisting}
  \begin{tad}
  \tadNom{Dictionnaire}
  \tadParametres{Element,Clef}
  \tadDependances{\booleen}
  \begin{tadOperations}{Dictionnaire}
    \tadOperation{dictionnaire}{}{\tadUnParam{Dictionnaire}}
  \end{tadOperations}
  \begin{tadSemantiques}{Dictionnaire}
    \tadSemantique{ajouter}{L'op�ration qui permet d'ajouter un �l�ment dans le Dictionnaire}
  \end{tadSemantiques}
  \begin{tadAxiomes}
    \tadAxiome{dictionnaire()}
  \end{tadAxiomes}
\end{tad}
\end{lstlisting}


Comme illustr� dans le Listing , on encadre la d�finition d'un type abstrait de donn�e par l'environnement \texttt{tad}.
 On utilise ensuite les commandes et environnements suivants :
\begin{itemize}
\item
  \begin{lstlisting}
     \tadNom{1}  
  \end{lstlisting}
  La commande \texttt{\textbackslash tadNom} qui permet de fixer le nom du TAD.


(1): Nom du tad 

\item
   \begin{lstlisting}
     \tadParametres{1}
  \end{lstlisting}
  La commande \texttt{\textbackslash tadParametres} qui permet de fixer le param�tre de ce TAD.


 (1) : Listes des param�tres
\item 
  \begin{lstlisting}
    \tadDependances{1}
  \end{lstlisting}
  La commande \texttt{\textbackslash tadDependances}  qui permet d'identifier  les types utilis�s par le TAD.  


 (1] : Listes des d�pendances

\item 
  \begin{lstlisting}
      \begin{tadOperations}{1}
              \tadOperation{2}{3}{4}
      \end{tadOperations}
  \end{lstlisting}
  L'environnement \texttt{tadOperations} qui permet de lister, � l'aide de la commande \texttt{\textbackslash tadOperation}, les op�rations du TAD. 
 (1) : Nom de l'op�ration qui a le plus de  caract�res (permetant d'aligner toutes les autres op�rations sur cette derni�re).
 La commande \texttt{\textbackslash tadOperation} admet trois arguments en param�tre :


 (2) : Nom de l'op�ration


 (3) : Le produit cart�sien des types en entr�e : il faut alors utiliser une des commandes suivantes :
      \begin{itemize}
        \item \texttt{\textbackslash tadUnParam} qui admet un argument en param�tre
       \item \texttt{\textbackslash tadDeuxParams} qui admet deux arguments en param�tre
        \item \texttt{\textbackslash tadTroisParams} qui admet trois arguments en param�tre
        \item etc. la limite �tant �  \texttt{\textbackslash tadHuitParams}
      \end{itemize}

 (4) : Le produit cart�sien des types en sortie, qui s'utilise de la m�me mani�re que le produit cart�sien des types en entr�e

  \item
    \begin{lstlisting}
        \begin{tadSemantiques}{1}
           \tadSemantique{2}{3}
        \end{tadSemantiques}
    \end{lstlisting}
   L'environnement \texttt{tadSemantiques} qui permet de lister, � l'aide de la commande \texttt{\textbackslash tadSemantique}, la signification des op�rations de ce TAD. 


 (1) : Nom de l'op�ration qui a le  plus de caract�res. 


 (2) : le nom de l'op�ration


 (3) : sa signification
  

  \item
    \begin{lstlisting}
        \begin{tadAxiomes}
           \tadAxiome{1}
        \end{tadAxiomes}
    \end{lstlisting}
   L'environnement \texttt{tadAxiomes} qui permet de lister, � l'aide de la commande \texttt{\textbackslash tadAxiome}, les axiomes du TAD. 

 (1) : Axiome 

\end{itemize}


Voici un exemple assez complet qui illustre toutes ces commandes.

\begin{lstlisting}
  
\begin{tad}
  \tadNom{Dictionnaire}
  \tadParametres{Element,Clef}
  \tadDependances{\booleen}
  \begin{tadOperations}{Dictionnaire}
    \tadOperation{dictionnaire}{}{\tadUnParam{Dictionnaire}}
    \tadOperation{ajouter}{\tadTroisParams{Dictionnaire}{Clef}{Element}}{\tadUnParam{Dictionnaire}}
    \tadOperation{retirer}{\tadDeuxParams{Dictionnire}{Clef}}{\tadUnParam{Element}}
  \end{tadOperations}
  \begin{tadSemantiques}{Dictionnaire}
    \tadSemantique{dictionnaire}{l'op�ration qui permet de construire un Dictionnaire
      � partir de sa partie r�elle et imaginaire}
    \tadSemantique{ajouter}{L'op�ration qui permet d'ajouter un �l�ment dans le Dictionnaire}
    \tadSemantique{retirer}{L'op�ration qui permet de retirer un �lement du Dictionnaire}
  \end{tadSemantiques}
  \begin{tadAxiomes}
    \tadAxiome{dictionnaire()}
    \tadAxiome{ajouter(ajouter(d,c,e),c,e)=ajouter(d,c,e)}
    \tadAxiome{retirer(ajouter(d,c,e),c)=d}
    \tadAxiome{obtenir(ajouter(d,c,e),c)=e}
  \end{tadAxiomes}
\end{tad}
\end{lstlisting}

Ce qui donne :

\begin{tad}
  \tadNom{Dictionnaire}
  \tadParametres{Element,Clef}
  \tadDependances{\booleen}
  \begin{tadOperations}{Dictionnaire}
    \tadOperation{dictionnaire}{}{\tadUnParam{Dictionnaire}}
    \tadOperation{ajouter}{\tadTroisParams{Dictionnaire}{Clef}{Element}}{\tadUnParam{Dictionnaire}}
    \tadOperation{retirer}{\tadDeuxParams{Dictionnire}{Clef}}{\tadUnParam{Element}}
  \end{tadOperations}
  \begin{tadSemantiques}{Dictionnaire}
    \tadSemantique{dictionnaire}{l'op�ration qui permet de construire un Dictionnaire
      � partir de sa partie r�elle et imaginaire}
    \tadSemantique{ajouter}{L'op�ration qui permet d'ajouter un �l�ment dans le Dictionnaire}
    \tadSemantique{retirer}{L'op�ration qui permet de retirer un �lement du Dictionnaire}
  \end{tadSemantiques}
  \begin{tadAxiomes}
    \tadAxiome{dictionnaire()}
    \tadAxiome{ajouter(ajouter(d,c,e),c,e)=ajouter(d,c,e)}
    \tadAxiome{retirer(ajouter(d,c,e),c)=d}
    \tadAxiome{obtenir(ajouter(d,c,e),c)=e}
  \end{tadAxiomes}
\end{tad}


\section{Commandes divers}

\subsection{La commande renewcommand}


Comment renommer les noms des instructions � l'affichage des algorithmes ? \\
C'est tr�s simple, il suffit d'utiliser la commande suivante:
\begin{lstlisting}
\renewcommand{\motclef[Nom de la commande]}[0]{[Nouveau nom affich�]}
\end{lstlisting}

Exemple:

\begin{lstlisting}
  \renewcommand{\motclefBooleen}[0]{Boolean}
  \renewcommand{\motclefReel}[0]{Real}
\end{lstlisting}

Ainsi, les instructions
\begin{lstlisting}
  \booleen
  \reel
\end{lstlisting}

donnent avant les renewcommand: 

\booleen   

\reel 

\renewcommand{\motclefBooleen}[0]{Boolean}
\renewcommand{\motclefReel}[0]{Real}

et apr�s les renewcommand: 

\booleen   

\reel

\subsection{La commande remarque}
La commande \texttt{\textbackslash remarque} sert � mettre ( donc ) des remarques dans l'algorihme.

\begin{lstlisting}
\begin{algorithme}
  \small
  \procedure
  {echanger}
  {\paramEntreeSortie{val1,val2 : \entier}}
  {temp : \entier}
  {\affecter{temp}{val1}
    \affecter {val1}{val2}
    \affecter {val2}{temp}
    \remarque{Une proc�dure ne renvoie pas de valeur }
  }
\end{algorithme}
\end{lstlisting}
Ce qui donne : 
\begin{algorithme}
  \small
  \procedure
  {echanger}
  {\paramEntreeSortie{val1,val2 : \entier}}
  {temp : \entier}
  {\affecter{temp}{val1}
    \affecter {val1}{val2}
    \affecter {val2}{temp}
    \remarque{Une proc�dure ne renvoie pas de valeur}

  }
\end{algorithme}

\end{document}
