\documentclass[a4paper,12pt]{report}
\usepackage{algorithme}
\usepackage[francais]{babel}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{algorithme}
\usepackage{listings}
\usepackage{color}
\usepackage{supertabular}
\usepackage{fullpage}



%%Configuration de listings -----------------------------------
\definecolor{colKeys}{rgb}{0,0,1}
\definecolor{colIdentifier}{rgb}{0,0,0}
\definecolor{colComments}{rgb}{0,0.5,1}
\definecolor{colString}{rgb}{0.6,0.6,0.1}

\lstset{%configuration de listings
float=hbp,%
basicstyle=\ttfamily\small, %
identifierstyle=\color{colIdentifier}, %
keywordstyle=\color{colKeys}, %
stringstyle=\color{colString}, %
commentstyle=\color{colComments}, %
columns=flexible, %
tabsize=2, %
frame=trBL, %
frameround=tttt, %
extendedchars=true, %
showspaces=false, %
showstringspaces=false, %
numbers=left, %
numberstyle=\tiny, %1
breaklines=true, %
breakautoindent=true, %
captionpos=b,%
xrightmargin=0cm, %
xleftmargin=-0cm, %
language=tex, %
frameround=fttt;%
}
%%Fin de la configuration de listings -----------------------------------



\title{Documentation du package  algorithme.sty \\version 2.3.6}
\author{RANDRIANARIVELO Tiana \\ MSSALAK Meryem \\ ZERJAL Dimitri \\ AMIRAULT Martin}
\begin{document}

\maketitle
\tableofcontents{}


\chapter{Présentation du package}

\section{Généralités}

Ce package est destiné à afficher des algorithmes dans les documents \LaTeX.
La présentation et la syntaxe ont été créé de manière à ce que les algorithmes soient compréhensibles par tous. 
Le surlignage en gras des termes important ainsi que l'indentation est faite automatiquement. Par ailleurs, tout les élements algorithmiques sont en français.
Le langage utilisé est détaché de toute syntaxe spécifique aux langages de programmation existants. Ceci permet de porter aisément l'algorithme dans n'importe lequel de ces langages.



\section{Historique}

La version stable du package \textbf{algorithme} est actuellement la version 2.3.6.
Voici l'historique des changements du package depuis sa sortie : 
\begin{itemize}
%% Envoyer toutes remarques a Nicolas.Delestre@insa-rouen.fr

  \item Modifications de puis la version 2.6\\
    \textbullet   Amélioration de la notation des pointeurs

  \item Modifications depuis la version 2.4\\
    \textbullet   Ajoute des commandes \textbackslash typeProcedure, \textbackslash typeFonction, \textbackslash typeProcedureAvecPreconditions, \textbackslash typeFonctionAvecPreconditions

  \item Modifications depuis la version 2.3.8\\
    \textbullet   Ajout de la commande \textbackslash tadOperationAvecPreconditions\\
    \textbullet   Ajout des environnement tadPreconditions et des commandes \textbackslash motclefTADPreconditions  et \textbackslash tadPrecondition\\
    \textbullet   Ajout de la commande \textbackslash champ


  \item Modifications depuis la version 2.3.7\\
    \textbullet   Ajout des types de base naturelNonNul, reelPositif, reelPositifNonNul (resp Negatif)\\
    \textbullet   Elimination d'accents dans les mots cles lies à l'algorithmique\\
    \textbullet   ajout de la commande \textbackslash commentaire
    
  \item Modification depuis la version 2.3.6 :\\
    \textbullet   Ajout des commandes \textbackslash fonctionAvecPreconditions \textbackslash signatureFonctionAvecPreconditions, \textbackslash procedureAvecPreconditions et \textbackslash signatureProcedureAvecPreconditions\\
    \textbullet   remplacement de structure et champEnregistrement par enregistrement et champEnregistrement\\

  \item  Modification depuis la version 2.3.5 :\\
   \textbullet   suppression de la commande \textbackslash programme
  
  \item Modification depuis la version 2.3.4 :\\
   \textbullet   Dans les commandes fonction et procedure, modification du test pour savoir si les variables locales sont presentes ou pas\\
   \textbullet   Suppression de l'erreur de compilation du a la redefinition de l'environnement structure\\

  \item  Modification depuis la version 2.3.2 :\\
   \textbullet structure est maintenant un environnement qui s'integre dans l'environnement algorithme\\
   \textbullet \textbackslash champEnregistrement a pris une majuscule\\
   \textbullet Apparition de \texttt{\textbackslash tadSemantiquesAxiomatiques}\\
   \textbullet   Apparition de l'environnement \texttt{\textbackslash tadAxiomes} et commande \texttt{\textbackslash tadAxiome}\\
   \textbullet   Apparition de \texttt{\textbackslash typePointeur}, \texttt{\textbackslash pointeur},\texttt{\textbackslash \pointeurNULL}, \texttt{\textbackslash champPointeur}, \texttt{\textbackslash allouer}, \texttt{\textbackslash desallouer}\\
   \textbullet   Elimination de l'erreur de compilation lié à la définition de la commande \texttt{\textbackslash structure}
\end{itemize}

\section{Installation}

Il y trois manières d'installer le Package \textbf{algorithme.sty} : 
\begin{enumerate}
  \item Il suffit de mettre le package dans le même dossier que le document lui-même.
L' inconvénient de cette méthode est qu'il faut toujours recopier le package \textbf{algorithme.sty} à chaque fois que l'on fait un nouveau document dans un autre dossier.

 \item La deuxième méthode consiste à chercher le dossier \textbf{texmf} dans le system, puis de copier le package \textbf{algorithme.sty} dans le dossier \textbf{tex} ( Normalement, ce dossier devrait se trouver dans \texttt{/usr/share/texmf/tex/} ) .Mais cette méthode reste dangereuse par le fait qu'il faut être root pour le faire. 

 \item La dernière méthode, qui est la méthode plus propre,  permet d'installer une fois pour toute le package sur la machine peut importe l'emplacement des documents sources \LaTeX.Il suffit de paramétrer le variable d'environment \textbf{HOMETEXMF}, en lui donnant comme valeur le réperoire où se trouve ses propres packages \LaTeX .

\end{enumerate}



\chapter{Utilisation du package}
Une fois installé (voir le paragraphe Installation), l'utilisation est semblable aux autres packages \LaTeX :


En tête du fichier \LaTeX, inclure la ligne suivante
\begin{lstlisting}
\usepackage{algorithme}
\end{lstlisting}

\section{L 'environnement Algorithme}

Entourer chaque algorithme par les balises suivantes:
\begin{lstlisting}
  \begin{algorithme}
...
  \end{algorithme}
\end{lstlisting}


\subsection{En-tête}

Les differents en-têtes disponibles dans le package sont les suivants:


\begin{lstlisting}
\algorithme{1}{2}{3}{4}{5}{6}{7}{8}
(1):Taille de la police
(2):Nom de l'algorithme
(3):Rôle de l'algorithme 
(4):Paramètres en entrée
(5):Paramètres en sortie
(6):Paramètres en entrée/sortie
(7):Déclaration variables locales
(8):Corps de l'algorithme
\end{lstlisting}

Exemple:

\begin{lstlisting}
\algo{\normalsize}
{exemple d'algo}
{présenter l'utilisation d'algo}
{n : \entier}
{m: \entier}
{t: \entier}
{i: \reel}
{\instruction{corps du programme}}
\end{lstlisting}

\begin{algorithme}
  \algo{\normalsize}
  {exemple d'algo}
  {présenter l'utilisation d'algo}
  {n : \entier}
  {m: \entier}
  {t: \entier}
  {i: \reel}
  {\instruction{corps du programme}}

\end{algorithme}


\subsection{Les types de base}

\subsubsection{Types simples}

Les commandes pour utiliser les types simples sont les suivantes:
\begin{lstlisting}
  Entier: \entier
  Entier naturel : \naturel
  Réel: \reel
  Booléen: \booleen
  Caractère: \caractere
  Chaine de caractères: \chaine
\end{lstlisting}

Exemple:

\begin{lstlisting}
  \algo
  {\normalsize}
  {Exemple de programme}
  {}
  {n: \naturel; e : \entier; r \reel; b: \booleen; c: \caractere; ch: \chaine}
  {}
  {}
  {}
  {\instruction{corps du programme}}

\end{lstlisting}

\begin{algorithme}
  \algo
  {\normalsize}
  {Exemple de programme}
  {}
  {n: \naturel; e : \entier; r \reel; b: \booleen; c: \caractere; ch: \chaine}
  {}
  {}
  {} 
  {\instruction{corps du programme}}

\end{algorithme}

\subsubsection{Types complexes}

Les commandes pour utiliser les types complexes sont les suivantes:
\begin{lstlisting}
  constante: \constante{1}{2}
(1): Nom de la constante
(2): Valeur de la constante

tableau unidimensionnel: \tableauUneDimension{1}{2}{3}
(1): Intervalle
(2): {de} ou {d'}
(3): Type

tableau bidimensionnel: \tableauDeuxDimensions {1}{2}{3}{4}
(1): Intervalle 1ere dimension
(2): Intervalle 2eme dimension
(3): {de} ou {d'}
(4): Type

\end{lstlisting}

 Exemples:
\begin{lstlisting}
  \algo
  {\normalsize}
  {Exemple de programme}
  {}
  
  {
  const: \constante{const}{2},
  tab1d: \tableauUneDimension{10}{d'}{\entier},
  tab2d: \tableauDeuxDimensions{10}{20}{de}{\reel}
  }
  {}
  {}
  {}
  {\instruction{}}

\end{lstlisting}

\begin{algorithme}
  \algo
  {\normalsize}
  {Exemple de programme}
  {}
  {
  const: \constante{const}{2},
  tab1d: \tableauUneDimension{10}{d'}{\entier},
  tab2d: \tableauDeuxDimensions{10}{20}{de}{\reel}
  }
  {}
  {}
  {}
  {\instruction{}}
\end{algorithme}



\subsection{Les instructions élémentaires}
Les instructions élémentaires sont l'affectation, la lecture et l'écriture de données, les commandes nécessaires pour les utiliser sont les suivantes:
\begin{lstlisting}
  affectation: \affecter{1}{2}
(1): Nom de la variable
(2): Valeur

 écriture: \ecrire{1}
(1): Ce qui doit être afficher

 lecture: \lire{1}
(1): Variable
\end{lstlisting}

Exemple:

\begin{lstlisting}
  \procedure
  {ajouterNombre}
  {a: \entier}
  {i: \entier}
  {
    \affecter{i}{0}
    \ecrire{Veuillez donner une valeur à ajouter à a}
    \lire{i}
    \affecter{a}{a + i}
  }
\end{lstlisting}


\begin{algorithme}
  \procedure
  {ajouterNombre}
  {a: \entier}
  {i: \entier}
  {
    \affecter{i}{0}
    \ecrire{Veuillez donner une valeur à ajouter à a}
    \lire{i}
    \affecter{a}{a + i}
  }
\end{algorithme}

\subsection {Les tests}

\begin{itemize}
   \item Supérieur ou égal ( $\geq$ )
       \begin{lstlisting}
          $\geq$
       \end{lstlisting}

   \item Inférieur ou égal ( $\leq$ )

        \begin{lstlisting}
          $\leq$
        \end{lstlisting}

   \item Différent de ( $\neq$ )

        \begin{lstlisting}
          $\neq$
        \end{lstlisting}

   \item Egal à ( = )
        \begin{lstlisting}
          =
        \end{lstlisting}
   \item Supérieur ( $>$ )
        \begin{lstlisting}
          $>$
        \end{lstlisting}
   \item Inférieur ( $<$ )

        \begin{lstlisting}
          $<$
        \end{lstlisting}
\end{itemize}

 \subsection {Les conditionnelles}
   \begin{lstlisting}
       \sialors{1}{2}
(1): Test de la conditionnelle
(2): Code à exectuter si le test est vérifié
        \sialorssinon{1}{2}{3}
(1): Test de la conditionnelle
(2): Code à executer si le test est vérifié
(3): Code à executer si le test n'est pas vérifié
   \end{lstlisting}

 Exemple:

 \begin{lstlisting}
    \begin{algorithme}
    \algo 
        {\small}
        {Test du signe d'un entier}
        {}
        {n : \entier}
        {}
        {}
        {}
        {
          \lire {n}
          \sialorssinon{n $\geq$ 0}
             {
               \ecrire{Vous avez entré un entier positif ou nul}
             }
             {
               \ecrire{Vous avez entré un entier négatif}
             }
       }
   \end{algorithme}
\end{lstlisting}

 \begin{algorithme}
    \algo
        {\small}
        {Test du signe d'un entier}
        {}
        {n : \entier}
        {}
        {}
        {}
        {
          \lire {n}
          \sialorssinon{n $\geq$ 0}
             {
               \ecrire{Vous avez entré un entier positif ou nul}
             }
             {
               \ecrire{Vous avez entré un entier négatif}
             }
       }
 \end{algorithme}


 \subsection{Les boucles}
 \subsubsection{detérministes}

 \begin{lstlisting}
 \pour{1}{2}{3}{4}{5}
(1):Nom de la variable
(2):Borne inférieure
(3):Borne Supérieure
(4):Pas (si non renseigné, 1)
(5):Corps de la boucle
 \end{lstlisting}


 \begin{lstlisting}
 \begin{algorithme}
     \algo 
     {\small}
     {Afficher les nombres de 1 à 100}
     {}
     {n : \naturel}
     {}
     {}
     {}
     {
        \pour{n}{1}{100}{}
           {
             \ecrire{n}
           }
     }
 \end{algorithme}

 \end{lstlisting}

 \begin{algorithme}
     \algo 
     {\small}
     {Afficher les nombres de 1 à 100}
     {}
     {n : \naturel}
     {}
     {}
     {}
     {
        \pour{n}{1}{100}{}
           {
             \ecrire{n}
           }
     }
 \end{algorithme}

 \subsubsection{indetérministes}
   \begin{lstlisting}
     \tantque{1}{2}
(1):Test de la boucle
(2):Corps de la boucle
   \end{lstlisting}

Exemple:
\begin{lstlisting}
  \begin{algorithme}
    \algo
    {\small}
    {Afficher les nombres de 1 à ?}
    {}
    {n : \naturel}
    {bornesup : \naturel}
    {}
    {}
    {
      \ecrire{Afficher les nombres de 1 à ?}
      \lire {bornesup}
      \tantque{n$<$bornesup+1}
         {
           \ecrire{n}
           \affecter {n}{n+1}
         }
    }
  \end{algorithme}
\end{lstlisting}

  \begin{algorithme}
    \algo
    {\small}
    {Afficher les nombres de 1 à }
    {}
    {n : \naturel}
    {bornesup : \naturel}
    {}
    {}
    {
      \affecter {n}{1}
      \ecrire{Afficher les nombres de 1 à ?}
      \lire {bornesup}
      \tantque{n $<$ bornesup+1}
         {
           \ecrire{n}
           \affecter {n}{n+1}
         }
    }
  \end{algorithme}



La commande \texttt{\textbackslash repeter} permet d'effectuer une boucle en exécutant au moins une fois le corps de boucle.

  \begin{lstlisting}
    \repeter{1}{2}
(1):Corps de la boucle
(2):Test de la boucle
  \end{lstlisting}
Exemple:
  \begin{lstlisting}
 \begin{algorithme}
   \algo 
   {\small}
   {Entrer un nombre entre 1 et 5}
   {}
   {}
   {}
   {reponse : \naturel}
   {}
   {
     \affecter{reponse}{0}
     \repeter {
       \ecrire {Entrez un nombre entre 1 et 5}
       \lire {reponse}
        }
       {(reponse $<$ 1)}
   }
 \end{algorithme}
\end{lstlisting}

 \begin{algorithme}
   \algo 
   {\small}
   {Entrer un nombre entre 1 et 5}
   {}
   {}
   {}
   {reponse : \naturel}
   {}
   { \affecter{reponse}{0}
     \repeter {
       \ecrire {Entrez un nombre entre 1 et 5}
       \lire {reponse}
        }
       {(reponse $<$ 1)}
   }
 \end{algorithme}

\subsection{Les fonctions et les procédures}

\subsubsection{Les fonctions}
Pour insérer une fonction, il faut utiliser la commande \texttt{\textbackslash fonction}  qui prend en paramètre cinq arguments :
\begin{lstlisting}
\fonction {1}{2}{3}{4}{5}
 (1) Le nom de la fonction 
 (2) Les paramètres 
 (3) Le type de retour
 (4) Les variables locales
 (5) Les instructions
\end{lstlisting}

Dans la liste des instructions, il doit y avoir au moins une fois
l'appel à la commande \texttt{\textbackslash retourner} qui admet un
argument en paramètre.

Exemple d'utilisation de la commande \texttt{\textbackslash fonction}

\begin{lstlisting}
\begin{algorithme}
  \small
  \fonction
  {abs}
  {unEntier : \entier}
  {\entier}
  {}
  {\sialorssinon{unEntier $\geq$ 0}
    {\retourner{unEntier}}
    {\retourner{-unEntier}}
  }    
\end{algorithme}
\end{lstlisting}


\begin{algorithme}
    \small
    \fonction
    {abs}
    {unEntier : \entier}
    {\entier}
    {}
    {\sialorssinon{unEntier $\geq$ 0}
      {\retourner{unEntier}}
      {\retourner{-unEntier}}
    }    
  \end{algorithme}

\subsubsection{Signature de fonction}

Pour insérer une signature de fonction, il faut utiliser la commande
\texttt{\textbackslash signaturefonction} qui prend en paramètre trois
arguments identiques aux trois premiers paramètres de la commande \texttt{\textbackslash fonction}
\begin{lstlisting}
\signaturefonction {1}{2}{3}
 (1) Le nom de la fonction 
 (2) Les paramètres 
 (3) Le type de retour
 \end{lstlisting}

\subsubsection{Les procédures}

Pour insérer une procédure, il faut utiliser la commande\texttt{\textbackslash procedure} qui prend en paramètre quatre arguments:
\begin{lstlisting}
\procedure {1}{2}{3}{4} 
 (1) nom de la procédure
 (2) Les paramètres
 (3) Les variables locales
 (4) Les instructions
\end{lstlisting}

Pour indiquer le passage de paramètre, on peut utiliser les commandes
\texttt{\textbackslash paramEntree}, \texttt{\textbackslash
  paramSortie} et \texttt{\textbackslash paramEntreeSortie}. Ces trois
commandes prennent un seul argument.

Exemple d'utilisation de la commande \texttt{\textbackslash procedure}
\begin{lstlisting}
\begin{algorithme}
  \small
  \procedure
  {echanger}
  {\paramEntreeSortie{val1,val2 : \entier}}
  {temp : \entier}
  {\affecter{temp}{val1}
    \affecter {val1}{val2}
    \affecter {val2}{temp}
  }
\end{algorithme}
\end{lstlisting}
\begin{algorithme}
    \small
    \procedure
    {echanger}
    {\paramEntreeSortie{val1,val2 : \entier}}
    {temp : \entier}
    {\affecter{temp}{val1}
      \affecter {val1}{val2}
      \affecter {val2}{temp}
    }
  \end{algorithme}

\subsubsection{Signature de procédure}

Tout comme pour les fonctions, on a la possibilité d'écrire une
signature de procédure à l'aide de la commande \texttt{\textbackslash
  signatureprocedure} qui prend en paramètre deux arguments identiques
aux deux premiers arguments de la commande \texttt{\textbackslash  procedure}

\begin{lstlisting}
\procedure {1}{2}
 (1) nom de la procédure
 (2) Les paramètres
\end{lstlisting}
  
\begin{lstlisting}
\algo
  {\small}
  {\textit{exemple}}
  {}
  {\variables{entier1,entier2,entier3,min,max : \entier}
    \signaturefonction{minimum2}{a,b : \entier}{\entier}
    \signaturefonction{minimum3}{a,b,c : \entier}{\entier}
    \procedure{calculerMinMax3}{\paramEntree{a,b,c : \entier};\paramSortie{min3,max3 : \entier}}
    {}
    {\affecter{min3}{minimum3(a,b,c)}
      \affecter{max3}{maximum3(a,b,c)}
    }
  }
  {}
  {}
  {}
  {\ecrire{"Entrez trois entiers :"}
    \lire{entier1}
    \lire{entier2}
    \lire{entier3}
    \instruction{calculerMinMax3(entier1,entier2,entier3,min,max)}
    \ecrire{"la valeur la plus petite est ",min," et la plus grande est ",max}
  }
\end{lstlisting}

Ce qui donne : 
\begin{algorithme}
  \algo
  {\small}
  {\textit{exemple}}
  {}
  {\variables{entier1,entier2,entier3,min,max : \entier}
    \signaturefonction{minimum2}{a,b : \entier}{\entier}
    \signaturefonction{minimum3}{a,b,c : \entier}{\entier}
    \procedure{calculerMinMax3}{\paramEntree{a,b,c : \entier};\paramSortie{min3,max3 : \entier}}
    {}
    {\affecter{min3}{minimum3(a,b,c)}
      \affecter{max3}{maximum3(a,b,c)}
    }
  }
  {}
  {}
  {}
  {\ecrire{"Entrez trois entiers :"}
    \lire{entier1}
    \lire{entier2}
    \lire{entier3}
    \instruction{calculerMinMax3(entier1,entier2,entier3,min,max)}
    \ecrire{"la valeur la plus petite est ",min," et la plus grande est ",max}
  }
\end{algorithme}


 \subsection{Les pointeurs}
\begin{itemize}
\item Pour définir le type de l'élement pointé on utilise la commande \texttt{\textbackslash typePointeur} qui prend un seul argument en paramètre.
\begin{lstlisting}
\typePointeur {1}
 (1) le type de l'element pointé
\end{lstlisting}
\item Pour déclarer un pointeur on utilise la commande \texttt{\textbackslash pointeur} qui prend un seul argument en paramètre.
\begin{lstlisting}
\pointeur {1}
 (1) l'adresse de l'élement pointé
\end{lstlisting}
\item Par défaut lorsqu'on déclare un pointeur, on ne sait pas sur quoi il pointe, on peut donc lui affecter à l'initialisation la valeur NULL  en utilisant la commande \texttt{\textbackslash pointeurNULL}  qui prend aucun argument en paramètre.

\item Pour définir le type du pointeur on utilise la commande \texttt{\textbackslash champPointeur} qui prend deux arguments en paramètre:
\begin{lstlisting}
\champPointeur {1}{2}
 (1) le pointeur 
 (1) l'élement pointé
\end{lstlisting}
\item Pour allouer/désallouer un espace mémoire on utilise respectivement les commandes suivantes \texttt{\textbackslash allouer} et \texttt{\textbackslash desallouer} qui prennent en paramètre un seul argument
\begin{lstlisting}
\allouer {1}
 (1) l'adresse allouée

\desallouer {1}
 (1) l'adresse désallouée
\end{lstlisting}
\end{itemize}


Exemple d'utilisation des pointeurs


\begin{lstlisting}
\begin{algorithme}
\type{listeChainee}{\typePointeur{noeud}}
\end{algorithme}

\begin{algorithme}
\begin{enregistrement}{noeud}
  \champEnregistrement{lElement}{Element}
  \champEnregistrement{listeSuivante}{listeChaînée}
\end{enregistrement}
\end{algorithme}

\begin{algorithme}

\procedure{ajouter}
{\paramEntreeSortie{l:ListeChaînée} \paramEntree{e: Element}}
{temp: ListeChaînée}
{
 \affecter{temp}{l}
\affecter{l}{\allouer{noeud}}
\affecter{\champPointeur{l}{Element}}{e}
\instruction{fixerListeSuivante(l,temp)}
}
\end{algorithme}
\end{lstlisting}

Ce qui donne :
\begin{algorithme}
\type{listeChainee}{\typePointeur{noeud}}
\end{algorithme}

\begin{algorithme}
\begin{enregistrement}{noeud}
  \champEnregistrement{lElement}{Element}
  \champEnregistrement{listeSuivante}{listeChaînée}
\end{enregistrement}
\end{algorithme}

\begin{algorithme}

\procedure{ajouter}
{\paramEntreeSortie{l:ListeChaînée} \paramEntree{e: Element}}
{temp: ListeChaînée}
{
 \affecter{temp}{l}
\affecter{l}{\allouer{noeud}}
\affecter{\champPointeur{l}{Element}}{e}
\instruction{fixerListeSuivante(l,temp)}

}

\end{algorithme}

\section{L'environment Enregistrement}

Les structures sont déclarées au sein même de l'environnement algorithme (entre les balises \textbackslash begin\{algorithme\} et \textbackslash end\{algorithme\}).

La syntaxe est la suivante:
\begin{lstlisting}
\begin{enregistrement}{1}
        \champEnregistrement{2}{3}
  ...
\end{enregistrement}

(1):Nom de la structure
(2):Nom du premier champ de la structure
(3):type du premier champ de la structure
\end{lstlisting}


\begin{lstlisting}

\begin{algorithme}
\begin{enregistrement}{date}
        \champEnregistrement{leJour}{\entier}
        \champEnregistrement{leMois}{\entier}
       \champEnregistrement{lAnnee}{\entier}
\end{enregistrement}
\end{algorithme}
\end{lstlisting}
\begin{algorithme}
\begin{enregistrement}{date}
        \champEnregistrement{leJour}{\entier}
        \champEnregistrement{leMois}{\entier}
       \champEnregistrement{lAnnee}{\entier}
\end{enregistrement}
\end{algorithme}



\section{L'environment TAD}


On a aussi la possibilité de définir des types abstraits de données
(que l'on retrouve dans la littérature sous les termes ``types de données
abstraits'' ou ``abstract datatype'').

\begin{lstlisting}
  \begin{tad}
  \tadNom{Dictionnaire}
  \tadParametres{Element,Clef}
  \tadDependances{\booleen}
  \begin{tadOperations}{Dictionnaire}
    \tadOperation{dictionnaire}{}{\tadUnParam{Dictionnaire}}
  \end{tadOperations}
  \begin{tadSemantiques}{Dictionnaire}
    \tadSemantique{ajouter}{L'opération qui permet d'ajouter un élément dans le Dictionnaire}
  \end{tadSemantiques}
  \begin{tadAxiomes}
    \tadAxiome{dictionnaire()}
  \end{tadAxiomes}
\end{tad}
\end{lstlisting}


Comme illustré dans le Listing , on encadre la définition d'un type abstrait de donnée par l'environnement \texttt{tad}.
 On utilise ensuite les commandes et environnements suivants :
\begin{itemize}
\item
  \begin{lstlisting}
     \tadNom{1}  
  \end{lstlisting}
  La commande \texttt{\textbackslash tadNom} qui permet de fixer le nom du TAD.


(1): Nom du tad 

\item
   \begin{lstlisting}
     \tadParametres{1}
  \end{lstlisting}
  La commande \texttt{\textbackslash tadParametres} qui permet de fixer le paramètre de ce TAD.


 (1) : Listes des paramètres
\item 
  \begin{lstlisting}
    \tadDependances{1}
  \end{lstlisting}
  La commande \texttt{\textbackslash tadDependances}  qui permet d'identifier  les types utilisés par le TAD.  


 (1] : Listes des dépendances

\item 
  \begin{lstlisting}
      \begin{tadOperations}{1}
              \tadOperation{2}{3}{4}
      \end{tadOperations}
  \end{lstlisting}
  L'environnement \texttt{tadOperations} qui permet de lister, à l'aide de la commande \texttt{\textbackslash tadOperation}, les opérations du TAD. 
 (1) : Nom de l'opération qui a le plus de  caractères (permetant d'aligner toutes les autres opérations sur cette dernière).
 La commande \texttt{\textbackslash tadOperation} admet trois arguments en paramètre :


 (2) : Nom de l'opération


 (3) : Le produit cartésien des types en entrée : il faut alors utiliser une des commandes suivantes :
      \begin{itemize}
        \item \texttt{\textbackslash tadUnParam} qui admet un argument en paramètre
       \item \texttt{\textbackslash tadDeuxParams} qui admet deux arguments en paramètre
        \item \texttt{\textbackslash tadTroisParams} qui admet trois arguments en paramètre
        \item etc. la limite étant à  \texttt{\textbackslash tadHuitParams}
      \end{itemize}

 (4) : Le produit cartésien des types en sortie, qui s'utilise de la même manière que le produit cartésien des types en entrée

  \item
    \begin{lstlisting}
        \begin{tadSemantiques}{1}
           \tadSemantique{2}{3}
        \end{tadSemantiques}
    \end{lstlisting}
   L'environnement \texttt{tadSemantiques} qui permet de lister, à l'aide de la commande \texttt{\textbackslash tadSemantique}, la signification des opérations de ce TAD. 


 (1) : Nom de l'opération qui a le  plus de caractères. 


 (2) : le nom de l'opération


 (3) : sa signification
  

  \item
    \begin{lstlisting}
        \begin{tadAxiomes}
           \tadAxiome{1}
        \end{tadAxiomes}
    \end{lstlisting}
   L'environnement \texttt{tadAxiomes} qui permet de lister, à l'aide de la commande \texttt{\textbackslash tadAxiome}, les axiomes du TAD. 

 (1) : Axiome 

\end{itemize}


Voici un exemple assez complet qui illustre toutes ces commandes.

\begin{lstlisting}
  
\begin{tad}
  \tadNom{Dictionnaire}
  \tadParametres{Element,Clef}
  \tadDependances{\booleen}
  \begin{tadOperations}{Dictionnaire}
    \tadOperation{dictionnaire}{}{\tadUnParam{Dictionnaire}}
    \tadOperation{ajouter}{\tadTroisParams{Dictionnaire}{Clef}{Element}}{\tadUnParam{Dictionnaire}}
    \tadOperation{retirer}{\tadDeuxParams{Dictionnire}{Clef}}{\tadUnParam{Element}}
  \end{tadOperations}
  \begin{tadSemantiques}{Dictionnaire}
    \tadSemantique{dictionnaire}{l'opération qui permet de construire un Dictionnaire
      à partir de sa partie réelle et imaginaire}
    \tadSemantique{ajouter}{L'opération qui permet d'ajouter un élément dans le Dictionnaire}
    \tadSemantique{retirer}{L'opération qui permet de retirer un élement du Dictionnaire}
  \end{tadSemantiques}
  \begin{tadAxiomes}
    \tadAxiome{dictionnaire()}
    \tadAxiome{ajouter(ajouter(d,c,e),c,e)=ajouter(d,c,e)}
    \tadAxiome{retirer(ajouter(d,c,e),c)=d}
    \tadAxiome{obtenir(ajouter(d,c,e),c)=e}
  \end{tadAxiomes}
\end{tad}
\end{lstlisting}

Ce qui donne :

\begin{tad}
  \tadNom{Dictionnaire}
  \tadParametres{Element,Clef}
  \tadDependances{\booleen}
  \begin{tadOperations}{Dictionnaire}
    \tadOperation{dictionnaire}{}{\tadUnParam{Dictionnaire}}
    \tadOperation{ajouter}{\tadTroisParams{Dictionnaire}{Clef}{Element}}{\tadUnParam{Dictionnaire}}
    \tadOperation{retirer}{\tadDeuxParams{Dictionnire}{Clef}}{\tadUnParam{Element}}
  \end{tadOperations}
  \begin{tadSemantiques}{Dictionnaire}
    \tadSemantique{dictionnaire}{l'opération qui permet de construire un Dictionnaire
      à partir de sa partie réelle et imaginaire}
    \tadSemantique{ajouter}{L'opération qui permet d'ajouter un élément dans le Dictionnaire}
    \tadSemantique{retirer}{L'opération qui permet de retirer un élement du Dictionnaire}
  \end{tadSemantiques}
  \begin{tadAxiomes}
    \tadAxiome{dictionnaire()}
    \tadAxiome{ajouter(ajouter(d,c,e),c,e)=ajouter(d,c,e)}
    \tadAxiome{retirer(ajouter(d,c,e),c)=d}
    \tadAxiome{obtenir(ajouter(d,c,e),c)=e}
  \end{tadAxiomes}
\end{tad}


\section{Commandes divers}

\subsection{La commande renewcommand}


Comment renommer les noms des instructions à l'affichage des algorithmes ? \\
C'est très simple, il suffit d'utiliser la commande suivante:
\begin{lstlisting}
\renewcommand{\motclef[Nom de la commande]}[0]{[Nouveau nom affiché]}
\end{lstlisting}

Exemple:

\begin{lstlisting}
  \renewcommand{\motclefBooleen}[0]{Boolean}
  \renewcommand{\motclefReel}[0]{Real}
\end{lstlisting}

Ainsi, les instructions
\begin{lstlisting}
  \booleen
  \reel
\end{lstlisting}

donnent avant les renewcommand: 

\booleen   

\reel 

\renewcommand{\motclefBooleen}[0]{Boolean}
\renewcommand{\motclefReel}[0]{Real}

et après les renewcommand: 

\booleen   

\reel

\subsection{La commande remarque}
La commande \texttt{\textbackslash remarque} sert à mettre ( donc ) des remarques dans l'algorihme.

\begin{lstlisting}
\begin{algorithme}
  \small
  \procedure
  {echanger}
  {\paramEntreeSortie{val1,val2 : \entier}}
  {temp : \entier}
  {\affecter{temp}{val1}
    \affecter {val1}{val2}
    \affecter {val2}{temp}
    \remarque{Une procédure ne renvoie pas de valeur }
  }
\end{algorithme}
\end{lstlisting}
Ce qui donne : 
\begin{algorithme}
  \small
  \procedure
  {echanger}
  {\paramEntreeSortie{val1,val2 : \entier}}
  {temp : \entier}
  {\affecter{temp}{val1}
    \affecter {val1}{val2}
    \affecter {val2}{temp}
    \remarque{Une procédure ne renvoie pas de valeur}

  }
\end{algorithme}

\end{document}
